(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.
Require ZArith.BinInt.
Require ZArith.Znat.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.true) <-> (x = y).

Axiom eqb_false :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.false) <-> ~ (x = y).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((neqb x y) = Init.Datatypes.true) <-> ~ (x = y).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zlt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom zleq1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zleq x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rlt x y) = Init.Datatypes.true) <-> (x < y)%R.

Axiom rleq1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rleq x y) = Init.Datatypes.true) <-> (x <= y)%R.

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

(* Why3 assumption *)
Inductive addr :=
  | addr'mk : Numbers.BinNums.Z -> Numbers.BinNums.Z -> addr.
Axiom addr_WhyType : WhyType addr.
Existing Instance addr_WhyType.

(* Why3 assumption *)
Definition base (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x
  end.

(* Why3 assumption *)
Definition offset (v:addr) : Numbers.BinNums.Z :=
  match v with
  | addr'mk x x1 => x1
  end.

Parameter addr_le: addr -> addr -> Prop.

Parameter addr_lt: addr -> addr -> Prop.

Parameter addr_le_bool: addr -> addr -> Init.Datatypes.bool.

Parameter addr_lt_bool: addr -> addr -> Init.Datatypes.bool.

Axiom addr_le_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_le p q <-> ((offset p) <= (offset q))%Z.

Axiom addr_lt_def :
  forall (p:addr) (q:addr), ((base p) = (base q)) ->
  addr_lt p q <-> ((offset p) < (offset q))%Z.

Axiom addr_le_bool_def :
  forall (p:addr) (q:addr),
  addr_le p q <-> ((addr_le_bool p q) = Init.Datatypes.true).

Axiom addr_lt_bool_def :
  forall (p:addr) (q:addr),
  addr_lt p q <-> ((addr_lt_bool p q) = Init.Datatypes.true).

(* Why3 assumption *)
Definition null : addr := addr'mk 0%Z 0%Z.

(* Why3 assumption *)
Definition global (b:Numbers.BinNums.Z) : addr := addr'mk b 0%Z.

(* Why3 assumption *)
Definition shift (p:addr) (k:Numbers.BinNums.Z) : addr :=
  addr'mk (base p) ((offset p) + k)%Z.

(* Why3 assumption *)
Definition included (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (0%Z < a)%Z ->
  (0%Z <= b)%Z /\
  ((base p) = (base q)) /\
  ((offset q) <= (offset p))%Z /\
  (((offset p) + a)%Z <= ((offset q) + b)%Z)%Z.

(* Why3 assumption *)
Definition separated (p:addr) (a:Numbers.BinNums.Z) (q:addr)
    (b:Numbers.BinNums.Z) : Prop :=
  (a <= 0%Z)%Z \/
  (b <= 0%Z)%Z \/
  ~ ((base p) = (base q)) \/
  (((offset q) + b)%Z <= (offset p))%Z \/
  (((offset p) + a)%Z <= (offset q))%Z.

(* Why3 assumption *)
Definition eqmem {a:Type} {a_WT:WhyType a} (m1:addr -> a) (m2:addr -> a)
    (p:addr) (a1:Numbers.BinNums.Z) : Prop :=
  forall (q:addr), included q 1%Z p a1 -> ((m1 q) = (m2 q)).

Parameter havoc:
  forall {a:Type} {a_WT:WhyType a}, (addr -> a) -> (addr -> a) -> addr ->
  Numbers.BinNums.Z -> addr -> a.

(* Why3 assumption *)
Definition valid_rw (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (0%Z < (base p))%Z /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_rd (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (m (base p)))%Z.

(* Why3 assumption *)
Definition valid_obj (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (0%Z < n)%Z ->
  (p = null) \/
  ~ (0%Z = (base p)) /\
  (0%Z <= (offset p))%Z /\ (((offset p) + n)%Z <= (1%Z + (m (base p)))%Z)%Z.

(* Why3 assumption *)
Definition invalid (m:Numbers.BinNums.Z -> Numbers.BinNums.Z) (p:addr)
    (n:Numbers.BinNums.Z) : Prop :=
  (n <= 0%Z)%Z \/
  ((base p) = 0%Z) \/
  ((m (base p)) <= (offset p))%Z \/ (((offset p) + n)%Z <= 0%Z)%Z.

Axiom valid_rw_rd :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  forall (n:Numbers.BinNums.Z), valid_rw m p n -> valid_rd m p n.

Axiom valid_string :
  forall (m:Numbers.BinNums.Z -> Numbers.BinNums.Z), forall (p:addr),
  ((base p) < 0%Z)%Z ->
  (0%Z <= (offset p))%Z /\ ((offset p) < (m (base p)))%Z ->
  valid_rd m p 1%Z /\ ~ valid_rw m p 1%Z.

Axiom separated_1 :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z),
  separated p a q b -> ((offset p) <= i)%Z /\ (i < ((offset p) + a)%Z)%Z ->
  ((offset q) <= j)%Z /\ (j < ((offset q) + b)%Z)%Z ->
  ~ ((addr'mk (base p) i) = (addr'mk (base q) j)).

Parameter region: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter linked: (Numbers.BinNums.Z -> Numbers.BinNums.Z) -> Prop.

Parameter sconst: (addr -> Numbers.BinNums.Z) -> Prop.

(* Why3 assumption *)
Definition framed (m:addr -> addr) : Prop :=
  forall (p:addr), ((region (base p)) <= 0%Z)%Z ->
  ((region (base (m p))) <= 0%Z)%Z.

Axiom separated_included :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), (0%Z < a)%Z ->
  (0%Z < b)%Z -> separated p a q b -> ~ included p a q b.

Axiom included_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> included q b r c -> included p a r c.

Axiom separated_trans :
  forall (p:addr) (q:addr) (r:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (c:Numbers.BinNums.Z),
  included p a q b -> separated q b r c -> separated p a r c.

Axiom separated_sym :
  forall (p:addr) (q:addr),
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  separated p a q b <-> separated q b p a.

Axiom eqmem_included :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr) (q:addr),
  forall (a1:Numbers.BinNums.Z) (b:Numbers.BinNums.Z), included p a1 q b ->
  eqmem m1 m2 q b -> eqmem m1 m2 p a1.

Axiom eqmem_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m1:addr -> a) (m2:addr -> a), forall (p:addr),
  forall (a1:Numbers.BinNums.Z), eqmem m1 m2 p a1 -> eqmem m2 m1 p a1.

Axiom havoc_access :
  forall {a:Type} {a_WT:WhyType a},
  forall (m0:addr -> a) (m1:addr -> a), forall (q:addr) (p:addr),
  forall (a1:Numbers.BinNums.Z),
  (separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m1 q))) /\
  (~ separated q 1%Z p a1 -> ((havoc m0 m1 p a1 q) = (m0 q))).

Parameter cinits: (addr -> Init.Datatypes.bool) -> Prop.

(* Why3 assumption *)
Definition is_init_range (m:addr -> Init.Datatypes.bool) (p:addr)
    (l:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < l)%Z ->
  ((m (shift p i)) = Init.Datatypes.true).

Parameter set_init:
  (addr -> Init.Datatypes.bool) -> addr -> Numbers.BinNums.Z ->
  addr -> Init.Datatypes.bool.

Axiom set_init_access :
  forall (m:addr -> Init.Datatypes.bool), forall (q:addr) (p:addr),
  forall (a:Numbers.BinNums.Z),
  (separated q 1%Z p a -> ((set_init m p a q) = (m q))) /\
  (~ separated q 1%Z p a -> ((set_init m p a q) = Init.Datatypes.true)).

(* Why3 assumption *)
Definition monotonic_init (m1:addr -> Init.Datatypes.bool)
    (m2:addr -> Init.Datatypes.bool) : Prop :=
  forall (p:addr), ((m1 p) = Init.Datatypes.true) ->
  ((m2 p) = Init.Datatypes.true).

Parameter int_of_addr: addr -> Numbers.BinNums.Z.

Parameter addr_of_int: Numbers.BinNums.Z -> addr.

Axiom table : Type.
Parameter table_WhyType : WhyType table.
Existing Instance table_WhyType.

Parameter table_of_base: Numbers.BinNums.Z -> table.

Parameter table_to_offset: table -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom table_to_offset_zero :
  forall (t:table), ((table_to_offset t 0%Z) = 0%Z).

Axiom table_to_offset_monotonic :
  forall (t:table), forall (o1:Numbers.BinNums.Z) (o2:Numbers.BinNums.Z),
  (o1 <= o2)%Z <-> ((table_to_offset t o1) <= (table_to_offset t o2))%Z.

Axiom int_of_addr_bijection :
  forall (a:Numbers.BinNums.Z), ((int_of_addr (addr_of_int a)) = a).

Axiom addr_of_int_bijection :
  forall (p:addr), ((addr_of_int (int_of_addr p)) = p).

Axiom addr_of_null : ((int_of_addr null) = 0%Z).

(* Why3 assumption *)
Definition P_SparseVectorInvariant
    (Malloc:Numbers.BinNums.Z -> Numbers.BinNums.Z) (Mptr:addr -> addr)
    (Mint:addr -> Numbers.BinNums.Z) (v:addr) : Prop :=
  let a := Mptr (shift v 0%Z) in
  let a1 := Mptr (shift v 1%Z) in
  let x := Mint (shift v 2%Z) in
  ((((((~ (a = a1) /\ (0%Z <= x)%Z) /\ separated v 3%Z a1 1%Z) /\
      separated v 3%Z a 1%Z) /\
     valid_rw Malloc (shift a 0%Z) x) /\
    valid_rw Malloc (shift a1 0%Z) x) /\
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z -> (i < x)%Z ->
    (0%Z <= (Mint (shift a1 i)))%Z)) /\
  (forall (i:Numbers.BinNums.Z) (i1:Numbers.BinNums.Z), ~ (i1 = i) ->
   (0%Z <= i)%Z -> (0%Z <= i1)%Z -> (i < x)%Z -> (i1 < x)%Z ->
   ~ ((Mint (shift a1 i1)) = (Mint (shift a1 i)))).

Parameter L_SparseVectorDenseSize_1_:
  (addr -> addr) -> (addr -> Numbers.BinNums.Z) -> addr ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom L_SparseVectorDenseSize_1__def :
  forall (Mptr:addr -> addr) (Mint:addr -> Numbers.BinNums.Z) (v:addr)
    (m:Numbers.BinNums.Z),
  let x := ((-1%Z)%Z + m)%Z in
  let x1 := Mint (shift (Mptr (shift v 1%Z)) x) in
  let x2 := L_SparseVectorDenseSize_1_ Mptr Mint v x in
  ((0%Z < m)%Z ->
   ((m <= (Mint (shift v 2%Z)))%Z ->
    ((x1 < x2)%Z -> ((L_SparseVectorDenseSize_1_ Mptr Mint v m) = x2)) /\
    (~ (x1 < x2)%Z -> ((L_SparseVectorDenseSize_1_ Mptr Mint v m) = x1))) /\
   (~ (m <= (Mint (shift v 2%Z)))%Z ->
    ((L_SparseVectorDenseSize_1_ Mptr Mint v m) = x2))) /\
  (~ (0%Z < m)%Z -> ((L_SparseVectorDenseSize_1_ Mptr Mint v m) = 0%Z)).

(* Why3 assumption *)
Definition P_SparseVectorDenseSizeValidTo
    (Malloc:Numbers.BinNums.Z -> Numbers.BinNums.Z) (Mptr:addr -> addr)
    (Mint:addr -> Numbers.BinNums.Z) (n:Numbers.BinNums.Z) : Prop :=
  forall (a:addr), (n <= (Mint (shift a 2%Z)))%Z ->
  P_SparseVectorInvariant Malloc Mptr Mint a -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> (i < n)%Z ->
  ((Mint (shift (Mptr (shift a 1%Z)) i)) <=
   (L_SparseVectorDenseSize_1_ Mptr Mint a n))%Z.

Axiom Q_SparseVectorDenseSizeValidStep :
  forall (Malloc:Numbers.BinNums.Z -> Numbers.BinNums.Z) (Mptr:addr -> addr)
    (Mint:addr -> Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> P_SparseVectorDenseSizeValidTo Malloc Mptr Mint n ->
  P_SparseVectorDenseSizeValidTo Malloc Mptr Mint (1%Z + n)%Z.

Axiom Q_SparseVectorDenseSizeValidBase :
  forall (Malloc:Numbers.BinNums.Z -> Numbers.BinNums.Z) (Mptr:addr -> addr)
    (Mint:addr -> Numbers.BinNums.Z),
  P_SparseVectorDenseSizeValidTo Malloc Mptr Mint 0%Z.

Lemma lemma_z_induction :
  forall P: Z -> Prop, 
    P 0%Z -> (forall i: Z, (i >= 0%Z)%Z -> P i -> P (i+1%Z)%Z) ->
      forall i: Z, (i >= 0%Z)%Z -> P i.
Proof.
intros P HB HS.
pose (Pnat (n : nat) := P (Z.of_nat n)).
assert (forall n : nat, Pnat n).
refine (nat_ind Pnat _ _).
exact HB.
intros n Hp.
assert (Hnat_eq : ((Z.of_nat n)+1%Z)%Z = Z.of_nat (S n)).
exact (eq_sym (Nat2Z.inj_succ n)).
refine (eq_ind (Z.of_nat n + 1)%Z P _ (Z.of_nat (S n)) Hnat_eq).
refine (HS (Z.of_nat n) _ _).
assert (HZ_of_nat_nneg : (Z.of_nat n >= Z.of_nat 0)%Z).
exact (inj_ge n 0 (Nat.le_0_l n)).
exact (eq_ind (Z.of_nat 0) (fun z:Z => (Z.of_nat n >= z)%Z)
  HZ_of_nat_nneg 0%Z Nat2Z.inj_0).
exact Hp.
intros i Hipos.
exact (eq_ind (Z.of_nat (Z.to_nat i)) P (H (Z.to_nat i)) i
  (Z2Nat.id i (proj1 (Z.ge_le_iff i 0) Hipos))).
Qed.

Lemma lemma_z_induction_2 :
  forall P: Z -> Prop, 
    P 0%Z -> (forall i: Z, (0%Z <= i)%Z -> P i -> P (1%Z+i)%Z) ->
      forall i: Z, (0%Z <= i)%Z -> P i.
Proof.
intros P HB HS i Hipos.
refine (lemma_z_induction P HB _ i (proj2 (Z.ge_le_iff i 0) Hipos)).
intros i0 Hi0pos HB0.
refine (eq_ind (1+i0)%Z P _ (i0+1)%Z (Z.add_comm 1 i0)).
exact (HS i0 (proj1 (Z.ge_le_iff i0 0) Hi0pos) HB0).
Qed.

(* Why3 goal *)
Theorem wp_goal :
  forall (t:Numbers.BinNums.Z -> Numbers.BinNums.Z)
    (t1:addr -> Numbers.BinNums.Z) (t2:addr -> addr) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> P_SparseVectorDenseSizeValidTo t t2 t1 i.
Proof.
intros t t1 t2 i h1.
exact (lemma_z_induction_2 (fun z:Z => P_SparseVectorDenseSizeValidTo t t2 t1 z)
  (Q_SparseVectorDenseSizeValidBase t t2 t1) (Q_SparseVectorDenseSizeValidStep t t2 t1)
  i h1).
Qed.

